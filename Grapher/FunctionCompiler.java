import java.io.*;
import javax.tools.*;
import java.util.HashSet;

/**
 * A helper class that constructs snippets of code that represent mathematical functions.
 */
public class FunctionCompiler {
    private static JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    private static int count = 0;

    private static HashSet<Character> numbers;
    private static HashSet<Character> letters;

    public static String interpretedFunction;

    public static void init() {
        numbers = new HashSet<>();
        for(int i = 48; i < 58; i++) 
            numbers.add(new Character((char)i));

        letters = new HashSet<>();
        for(int i = 97; i < 123; i++) 
            letters.add(new Character((char)i));
    }

    /**
     * Compiles the given fragment, placing it in the required format.
     */
    public static Function compile(String code) {  
        //A string representation of the code.
        interpretedFunction = code;

        //If the code is blank, then clear the Function.
        if(code.trim().equals("")) 
            return null;

        //Prevents people from abusing the program.
        /*
        if(code.contains("java") || code.contains("new")) {
        interpretedFunction = "Stop trying to break the program.";
        return null;
        }*/

        //Lets you use carets instead of pow(x,num). x^3 -> pow(x,3)
        for(int i = 0; i < code.length(); i++) {
            if(code.charAt(i) == '^') {
                int j = code.indexOf(" ", i);
                if(j == -1) j = code.length();

                String s = code.substring(i - 1, j);
                code = code.replace(s, "pow(" + code.charAt(i - 1) + ", " + s.substring(2) + ")");
            }
        }

        //Lets you skip using multiplication symbols right before variables. 4x -> 4*x ; 4cos(x) -> 4*cos(x)
        for(int i = 0; i < code.length(); i++) {
            if(letters.contains(new Character(code.charAt(i)))) {
                if(i > 0) {
                    if(numbers.contains(new Character(code.charAt(i-1)))) {
                        code = code.substring(0, i) + "*" + code.substring(i);
                    }
                }
            }
        }

        //Lets you use exclamation marks instead of factorial methods. 5! -> fac(5)
        for(int i = 0; i < code.length(); i++) {
            if(code.charAt(i) == '!') {
                //for(int j = i-1; j > 0 && 
                System.out.println("Old:"+code);
                code = code.substring(0, i - 1) + "fac(" + code.substring(i - 1, i) + ")" + code.substring(i + 1);
                System.out.println("New:"+code);
            }
        }

        //Lets you skip typing "return" at the start.
        if(!code.startsWith("return"))
            code = "return " + code;

        //Lets you skip the semicolon at the end.
        if(!code.endsWith(";"))
            code = code + ";";

        //Generate the stub text.
        String text = 
            "//Autogenerated code stub for use in graphing.\n" +
            "public class Stub" + count + " extends Function {\n" +
            "   public double evaluate(double x) {\n" +
            "       " + code + "\n" +
            "   }\n" +
            "}";

        //Write the contents to the appropriate file.
        File f = new File(System.getProperty("user.dir") + File.separator + "Stub" + count + ".java");
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(f))) {
            writer.write(text);
            writer.close();
        } catch (IOException i) {
            System.out.println("Failed to write code to file!");
            i.printStackTrace();
            return null;
        }

        //Compile the file.
        int result = compiler.run(null, null, null, "-cp", new File(System.getProperty("user.dir")).getAbsolutePath(), f.getAbsolutePath());
        if(result != 0) {
            System.out.println("Failed to compile code!");
            interpretedFunction = "Error!";
            return null;
        }

        //Delete the source.
        f.delete();

        //Return an instance of the created Stub.
        try {
            Function toReturn = (Function)(Class.forName("Stub" + count).newInstance());
     
            //Delete the compiled file, too! We don't need stubageddon.
            //Also, count up by one to change the file we're saving to.
            new File(System.getProperty("user.dir") + File.separator + "Stub" + count++ + ".class").delete();
            
            return toReturn;
        } catch (Exception e) {
            System.out.println("Failed to execute compiled code!");
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Deletes all of the Stubs generated this session.
     */
    public static void cleanup() {
        /*
        while(count-- >= 0) {
        String s = System.getProperty("user.dir") + File.separator + "Stub" + count + ".class";
        System.out.println("Deleting " + s);
        new File(s).delete();
        }*/

        for(File f : new File(System.getProperty("user.dir")).listFiles()) 
            if(f.getName().startsWith("Stub"))
                f.delete();
    }

    /**
     * Returns the current count of the compiler.
     */
    public static int getCount() {
        return count;
    }
}